
[TOC]
# JavaSE学习笔记
---

## 1.日常注意点
### 1.1 命名规范
- 包名：小写
- 类名，接口名：首字符大写
- 变量，方法名：驼峰命名法
- 常量名：全部大写
### 1.2 字节大小
> char:2字节 　float:4字节 　double:8字节
### 1.3 JUnit单元测试方法的使用
1. 测试方法上面必须使用@Test注解进行修饰。
2. 测试方法必须使用public void 进行修饰，不能带有任何参数。
3. 新建一个源代码目录用来存放测试代码。
4. 测试类的包应该与被测试类的包保持一致。
5. **具体配置环境和使用方法可以看“Ubuntu重装操作”里面的“IDEA”**

## 2.基本语法
### 2.1 运算符
- s+=2; 和 s=s+2;区别(+完之后是否会改变s的类型)
- 左移、右移符号(">>"_带符号右移；">>>"_不带符号右移)
- '^'异或符号（实现交换两个变量的值）
- break和continue 带标签的使用方法

### 2.2数组
#### 2.2.1 数组的默认初始化值
- **注意** 类里面的基本数据类型默认值同理(不是类内部的话基本数据类型要初始化，不然会报错)
- byte short int long 初始化默认值为0
- float double 初始化默认值为0.0
- char 初始化默认值为空格‘’
- booelean 初始化默认值为false
- 对于引用类型构成的数组而言， 初始化默认值为null
#### 2.2.2 null类型调用‘toString’方法引发空指针错误
#### 2.2.3 Arrays.sort()数组排序算法  

## 3.面向对象编程
> **三大特征**：封装 继承 多态
> **类的成员**: 属性 方法 构造器 初始化块 内部类
### 3.1匿名类对象的使用
> 只能在创建的时候调用一次

### 3.2 可变个数的形参的方法
- 格式：对于方法的形参，(数据类型 ... 形参名)
- 注意1：使用可变个数的形参方法 与 方法的形参使用数组 是一致的,如下
```java
public void sayHello(String ... args);
public void sayHello(String[]  args); 
```
- 注意2：若方法中存在可变个数的形参，那么一定要声明在形参的最后
```java
public void sayHello(int i, String ... args);
```
- 注意3：在一个方法中，最多声明一个可变参数的形参

### 3.3 方法的参数传递
> **规则**：java中的参数传递机制:值传递机制
> 1)形参是基本数据类型: 实参的值 -> 形参的基本数据类型的变量
> 2)形参是引用数据类型：实参的引用类型变量的值 -> 形参的引用类型变量

### 3.4 权限修饰符
- public
- protected
- 缺省
- private
> 以上用来修饰属性、方法，其中以上四个只有“public”和“缺省”可以修饰类

### 3.5 “this”关键字
- this(name);可以用来显示的调用当前类的重载的指定的构造器
- this(形参列表)必须在首行

### 3.6 "package"和"import"关键字
- "import static"导入包里面的属性或者方法
- “import java.lang.*”只能导入"lang"下的所有类或接口，其后的子类不能导入

## 4 类的高级特性1
### 4.1 继承
- extends关键字
- 当父类中有私有属性或方法时，子类获取的得到，但是由于封装性的原因，不能直接调用
- 仅支持单继承
#### 4.1.1 方法的重写(覆盖)
> 子类继承父类之后，父类的方法不适用，子类可以对父类的方法进行重写、覆盖
> 明白和"方法的重载"的区别
> **重写规则：**
> 1) 要求子类方法的“返回值类型 方法名(参数列表)”与父类方法一样
> 2) 子类方法的修饰符不能小于父类方法的修饰符
> 3) 若父类抛出异常，则子类方法抛出的异常类型不能大于父类的
> 4) 子父类的方法必须同为static或同为非static的
#### 4.1.2 super关键字
- 构造器默认：super()->调用父类的构造器,必须在首行
- super.属性名 ->调用父类属性
- super.方法名 ->调用父类方法
- 子类、父类的方法和属性重名时，要调用父类的就用super关键字
- 和“this(形参列表)”不能同时存在，两个都没有写的时候，默认调用super()

### 4.2 多态
- 子类对象的多态性：父类的引用指向子类对象(实际调用的是子类重写父类的方法)
- 向上转型，向下转型，小到大强制转型：Person p = new Woman; Woman w = (Woman)p;
- 传参数时：向下转型public void fun(Animal a){} //可以传"new Dog()"进去
- 属性不存在多态性

### 4.3 Object类及equals()、toString()方法
#### 4.3.1 equals()方法
- ”==“ 符号对于引用数据类型：比较的是引用类型变量的地址值是否相等
- 只能处理引用类型变量
- 有些类(如“String”)重写了equals()方法
- **String类**：创建的常量放在“字符串常量池”里面

#### 4.3.2 toString()方法
- 打印一个对象的引用时，实际就是调用该对象的toString()方法
    > 没有重写的toString()方法返回 该对象所在的类及对应的堆空间对象实体的首地址值

### 4.4 包装类(Wrapper)
     针对八种基本定义相应的引用类型--包装类(有了类的特点，就可以调用类中的方法)

基本数据类型 | 包装类
:---: | :---:
boolean | Boolean
byte | Byte
short | Short
int | **Integer**
long | Long
char | **Character**
float | Float
double | Double

     基本数据类型 包装类 String 三者之间的转换

转换 | 方法
:---: | :---
基本数据类型 ---> 包装类 | 调用包装类的构造器 Integer **Ex:** Integer i1 = new Integer(i);
包装类 ---> 基本数据类型 | 调用包装类的xxxValue()方法 **Ex:** int i2 = i1.intValue();
基本数据类型、包装类---> String | 调用String类的valueOf(xxx)方法 **Ex:** String str2 = String.valueOf(12)
String--->基本数据类型、包装类 | 调用包装类的parseXxx()方法 **Ex:** int i = Integer.parseInt(str2)

- **注意**：
1. Boolean构造器输入字符串是除了“true”,其余全是返回“false”
2. JDK5.0之后，有自动装箱和拆箱(**装箱：** Integer i3 = 23  **拆箱：** int i5 = i3)

## 4 类的高级特性2
### 4.1 static关键字
    静态结构的生命周期早于非静态的结构，同时被回收也晚于非静态结构
**修饰属性(类属性)**
- 存放位置：静态域
- 实例变量 or 类变量(static)
- 直接通过类调用
**修饰方法(类方法)**
- 非静态的方法可以调用静态方法
- 静态方法里面不能有this或super关键字的
- 静态方法只能调用静态的方法或者静态属性

### 4.2 单例设计模式
**使得一个类只能创建一个对象实例**
- 饿汉式和懒汉式(区别：创建类的时间是在类加载时，还是在第一次调用单体类时)
- Runtime类也是一个单体类
```java
//饿汉式
class Singleton {
    //1.私有化构造器，使得在类的外部不能够调用此构造器
    private Singleton() {
    }
    //2.在类的内部创建一个类的实例
    private static Singleton instance = new Singleton();

    //3.私有化此对象，通过公共的方法来调用
    //4.此公共的方法，只能通过类来调用，因为设置为static的,同时类的实例也必须为static声明的
    public static Singleton getInstance() {
        return instance;
    }
}

//懒汉式：可能存在线程安全问题
public static Singleton1 getInstance() {
        if(instance == null){
            instance = new Singleton1();
        }
        return instance;
    }
```

### 4.3 类的初始化块(或代码块)
1. 代码块如果有修饰符的话，那么只能使用static
2. 静态代码块
    ```java
    static{
    }
    ```
    >(1)随着类的加载而加载
    >(2)内部只能执行静态的结构(类属性、类方法)

3. 非静态代码块
    >(1)可以为类的属性进行初始化
    >(2)可以有多个代码块，顺序执行
    >(3)每创建一个对象，代码块就加载一次
    >(4)非静态代码块的执行顺序早于构造器

### 4.4 final关键字
- 修饰类:不能被继承
- 修饰方法：不能被重写
- 修饰属性：此属性就是一个常量，初始化后不可再被赋值，习惯上，常量用大写字符表示
    ①此常量不能使用默认初始化
    ②显示的赋值、代码块、构造器
**变量用static、final修饰**：全局常量

### 4.5 抽象类(abstract)
```java
abstract class Person{ // 抽象类
    public abstract void eat(); // 抽象方法
    public abstract void walk();
}
```
#### 4.5.1. 修饰类：抽象类
    ①不可以被实例化
    ②抽象类有构造器
    ③抽象方法所在类一定是抽象类
#### 4.5.2. 修饰方法：抽象方法
    ①若子类继承抽象类，**没有重写**所有的抽象方法，意味着此类中仍有抽象类，则此类必须声明为抽象的！
#### 4.5.3. **注意**：abstract 不能用来修饰属性、构造器、private、final、static(原因)
    - 属性：本身就不能修饰
    - 构造器：构造器不能被重写
    - private:子类不能覆盖（或重写）声明为private的方法的
    - final
    - static:直接通过类调用但是却没有功能，所以不能